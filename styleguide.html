<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Styleguide</title>
    <link rel="icon" type="image/svg+xml" href="assets/images/favicon.svg" />
    <!-- Chargement des fichiers CSS générés de l'app -->
    <link rel="stylesheet" href="assets/css/theme.css" />
    <link rel="stylesheet" href="assets/css/theme-tokens.css" />
    <link rel="stylesheet" href="assets/css/layouts.css" />
    <style>
      [data-layout*="autogrid"] {
        --col-min-size: 200px;
      }

      body {
        max-width: 1440px;
        margin: 0 auto;
        padding: 2rem;
        background: var(--surface, #ffffff);
        color: var(--on-surface, #000000);
        font-family: system-ui, sans-serif;
      }

      .header {
        margin-bottom: 2rem;
        padding-bottom: 1rem;
        border-bottom: 2px solid var(--primary, #007bff);
      }

      .header h1 {
        margin: 0 0 0.5rem;
        color: var(--accent, #666666);
      }

      .header p {
        margin: 0;
        color: var(--on-surface, #ffffff);
      }

      .back-link {
        display: inline-block;
        margin-bottom: 1rem;
        padding: 0.5rem 1rem;
        border: 1px solid var(--on-surface, #ffffff);
        border-radius: 4px;
        color: var(--on-surface, #ffffff);
        font-size: 0.9rem;
        text-decoration: none;
      }

      .back-link:hover {
        background: var(--primary, #007bff);
        color: var(--on-primary, #ffffff);
      }

      .section {
        margin-bottom: 3rem;
      }

      .section h2 {
        margin-bottom: 1.5rem;
        padding-bottom: 0.5rem;
        border-bottom: 2px solid var(--primary, #007bff);
      }

      .section h3 {
        margin-bottom: 1rem;
        color: var(--accent, #666666);
      }

      .token-demo {
        margin-bottom: 0.5rem;
        padding: 1rem;
        border: 1px solid var(--border-light, #e0e0e0);
        border-radius: 8px;
        background: var(--surface, #ffffff);
      }

      .color-swatch {
        width: 4rem;
        height: 3rem;
        margin-bottom: 0.5rem;
        border: 1px solid var(--border-light, #e0e0e0);
        border-radius: 4px;
      }

      .spacing-ruler {
        height: 0.25rem;
        margin-bottom: 0.5rem;
        background: var(--primary, #007bff);
      }

      .typo-sample {
        margin-bottom: 0.5rem;
        overflow: hidden;
        text-overflow: ellipsis;

        & > * {
          white-space: nowrap;
        }
      }

      .variable-name {
        color: var(--accent, #666666);
        font-family: ui-monospace, monospace;
        font-size: 0.9em;
      }

      .loading {
        padding: 2rem;
        color: var(--accent, #666666);
        text-align: center;
      }

      .error {
        margin: 1rem 0;
        padding: 1rem;
        border-radius: 4px;
        background: #f8d7da;
        color: #dc3545;
      }

      @media (width <= 48rem) {
        .grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <a href="index.html" class="back-link">← Retour à l'application</a>

      <header class="header">
        <h1>Styleguide</h1>
        <p>
          Génération automatique basée sur les fichiers CSS configurés dans
          l'application
        </p>
      </header>

      <div id="loading" class="loading">
        <p>Chargement des fichiers CSS...</p>
      </div>

      <div id="content" data-layout="autogrid" style="display: none">
        <div>
          <div class="section">
            <h2>Tokens Sémantiques (theme-tokens.css)</h2>
            <div id="tokens-content">
              <!-- Contenu généré dynamiquement -->
            </div>
          </div>
        </div>

        <div>
          <div class="section">
            <h2>Primitives (theme.css)</h2>
            <div id="primitives-content">
              <!-- Contenu généré dynamiquement -->
            </div>
          </div>
        </div>
      </div>

      <div id="error" style="display: none"></div>
    </div>

    <script>
      class StyleguideGenerator {
        constructor() {
          this.tokens = {};
          this.primitives = {};
          this.init();
        }

        async init() {
          try {
            await this.loadCSSFiles();
            this.generateStyleguide();
            this.hideLoading();
          } catch (error) {
            this.showError(`Erreur lors du chargement : ${error.message}`);
          }
        }

        async loadCSSFiles() {
          // Chargement des fichiers CSS depuis la racine de l'app
          const [tokensResponse, primitivesResponse] = await Promise.all([
            fetch("./assets/css/theme-tokens.css"),
            fetch("./assets/css/theme.css"),
          ]);

          if (!tokensResponse.ok || !primitivesResponse.ok) {
            throw new Error("Impossible de charger les fichiers CSS");
          }

          const tokensCSS = await tokensResponse.text();
          const primitivesCSS = await primitivesResponse.text();

          // Logs pour déboguer le contenu chargé
          console.log("=== CONTENU theme.css CHARGÉ ===");
          console.log(primitivesCSS.substring(0, 1000) + "...");
          console.log("=== FIN CONTENU ===");

          // Parse des variables CSS
          this.tokens = this.parseCSS(tokensCSS);
          this.primitives = this.parseCSS(primitivesCSS);

          console.log("Tokens trouvés:", Object.keys(this.tokens).length);
          console.log(
            "Primitives trouvées:",
            Object.keys(this.primitives).length
          );
        }

        parseCSS(cssContent) {
          const variables = {};

          // Expression régulière pour capturer les variables CSS
          const variableRegex = /--([a-zA-Z0-9-]+):\s*([^;]+);/g;
          let match;

          while ((match = variableRegex.exec(cssContent)) !== null) {
            const [, name, value] = match;
            const fullName = `--${name}`;

            // Variables fantômes non canoniques à exclure
            const phantomTextVariables = [
              "--text-10",
              "--text-11",
              "--text-12",
              "--text-13",
              "--text-15",
              "--text-17",
            ];

            // Variables mal catégorisées à exclure
            const excludedVariables = [
              "--checkable-size", // N'est pas une couleur
              "--form-control-spacing", // S'affiche mal
            ];

            // Filtre les variables qui ne devraient pas être affichées
            const shouldExclude =
              fullName.startsWith("--gap") ||
              fullName.includes("line-height") ||
              phantomTextVariables.includes(fullName) ||
              excludedVariables.includes(fullName);

            if (shouldExclude) {
              console.log("Variable filtrée:", fullName);
            } else {
              variables[fullName] = value.trim();
            }
          }

          return variables;
        }

        generateStyleguide() {
          this.generateTokensSection();
          this.generatePrimitivesSection();
        }

        generateTokensSection() {
          const container = document.getElementById("tokens-content");
          const sections = this.categorizeTokens(this.tokens);

          Object.entries(sections).forEach(([category, vars]) => {
            if (vars.length === 0) return;

            const section = document.createElement("div");
            section.innerHTML = `<h3>${this.getCategoryTitle(category)}</h3>`;

            const content = document.createElement("div");
            if (
              category === "colors" ||
              category === "breakpoints" ||
              category === "spacing" ||
              category === "borders"
            ) {
              content.setAttribute("data-layout", "autogrid");
              content.setAttribute("data-gap", "s");
            }

            // Pour les catégories typographiques, regrouper dans un seul token-demo
            if (
              category === "fontFamilies" ||
              category === "fontWeights" ||
              category === "fontSizes"
            ) {
              const groupDemo = document.createElement("div");
              groupDemo.className = "token-demo";

              vars.forEach(([name, value]) => {
                const typoSample = this.createTypoSample(name, value, category);
                groupDemo.appendChild(typoSample);
              });

              content.appendChild(groupDemo);
            } else {
              vars.forEach(([name, value]) => {
                content.appendChild(
                  this.createTokenDemo(name, value, category)
                );
              });
            }

            section.appendChild(content);
            container.appendChild(section);
          });
        }

        generatePrimitivesSection() {
          const container = document.getElementById("primitives-content");
          const sections = this.categorizeTokens(this.primitives);

          Object.entries(sections).forEach(([category, vars]) => {
            if (vars.length === 0) return;

            const section = document.createElement("div");
            section.innerHTML = `<h3>${this.getCategoryTitle(category)}</h3>`;

            const content = document.createElement("div");
            if (
              category === "colors" ||
              category === "breakpoints" ||
              category === "spacing" ||
              category === "borders"
            ) {
              content.setAttribute("data-layout", "autogrid");
              content.setAttribute("data-gap", "s");
            }

            // Pour les catégories typographiques, regrouper dans un seul token-demo
            if (
              category === "fontFamilies" ||
              category === "fontWeights" ||
              category === "fontSizes"
            ) {
              const groupDemo = document.createElement("div");
              groupDemo.className = "token-demo";

              vars.forEach(([name, value]) => {
                const typoSample = this.createTypoSample(
                  name,
                  value,
                  category,
                  true
                );
                groupDemo.appendChild(typoSample);
              });

              content.appendChild(groupDemo);
            } else {
              vars.forEach(([name, value]) => {
                content.appendChild(
                  this.createTokenDemo(name, value, category, true)
                );
              });
            }

            section.appendChild(content);
            container.appendChild(section);
          });
        }

        categorizeTokens(tokens) {
          const categories = {
            colors: [],
            breakpoints: [],
            spacing: [],
            fontFamilies: [],
            fontWeights: [],
            fontSizes: [],
            borders: [],
            other: [],
          };

          Object.entries(tokens).forEach(([name, value]) => {
            if (
              name.includes("color") ||
              name.includes("surface") ||
              name.includes("primary") ||
              name.includes("accent") ||
              name.includes("error") ||
              name.includes("success") ||
              name.includes("warning") ||
              name.includes("info") ||
              name.includes("layer-") ||
              name.includes("link") ||
              name.includes("selection") ||
              name.includes("background") ||
              name.startsWith("--on-") ||
              name.includes("checkable")
            ) {
              categories.colors.push([name, value]);
            } else if (
              name === "--md" ||
              name === "--lg" ||
              name === "--xl" ||
              name === "--xxl"
            ) {
              categories.breakpoints.push([name, value]);
            } else if (name.includes("spacing") && !name.includes("gap")) {
              categories.spacing.push([name, value]);
            } else if (
              name.includes("font-base") ||
              name.includes("font-mono") ||
              name.includes("font-poppins")
            ) {
              categories.fontFamilies.push([name, value]);
            } else if (name.includes("font-weight")) {
              categories.fontWeights.push([name, value]);
            } else if (name.includes("text-")) {
              categories.fontSizes.push([name, value]);
            } else if (name.startsWith("--radius-")) {
              categories.borders.push([name, value]);
            } else {
              categories.other.push([name, value]);
            }
          });

          return categories;
        }

        getCategoryTitle(category) {
          const titles = {
            colors: "Couleurs",
            breakpoints: "Breakpoints",
            spacing: "Espacements",
            fontFamilies: "Familles de police",
            fontWeights: "Graisses de police",
            fontSizes: "Tailles de texte",
            borders: "Border-radius",
            other: "Autres",
          };
          return titles[category] || "Divers";
        }

        createTokenDemo(name, value, category, showValue = false) {
          const demo = document.createElement("div");
          demo.className = "token-demo";

          if (category === "colors") {
            demo.innerHTML = `
              <div class="color-swatch" style="background-color: var(${name})"></div>
              <div class="variable-name">${name}</div>
            `;
          } else if (category === "spacing") {
            demo.innerHTML = `
              <div class="spacing-ruler" style="width: var(${name})"></div>
              <div class="variable-name">${name}${
              showValue ? ` - ${value}` : ""
            }</div>
            `;
          } else if (category === "breakpoints") {
            // Calculer la valeur en pixels (rem * 16)
            const remValue = parseFloat(value.replace("rem", ""));
            const pxValue = remValue * 16;
            const displayValue = showValue ? ` - ${value} - ${pxValue}px` : ``;

            demo.innerHTML = `
              <div class="variable-name">${name}${displayValue}</div>
            `;
          } else {
            demo.innerHTML = `
              <div class="variable-name">${name}${
              showValue ? ` - ${value}` : ""
            }</div>
            `;
          }

          return demo;
        }

        createTypoSample(name, value, category, showValue = false) {
          const sample = document.createElement("div");
          sample.className = "typo-sample";

          const isLargeFont =
            name.includes("text-48") ||
            name.includes("text-64") ||
            name.includes("text-80");

          let styleProperty = "font-size";
          if (category === "fontWeights") {
            styleProperty = "font-weight";
          } else if (category === "fontFamilies") {
            styleProperty = "font-family";
          }

          sample.innerHTML = `
            <div style="${styleProperty}: var(${name})" ${
            isLargeFont ? 'data-large="true"' : ""
          }>
              <span class="variable-name">${name}</span>${
            showValue ? ` - ${value}` : ""
          } — Exemple de texte
            </div>
          `;

          return sample;
        }

        hideLoading() {
          document.getElementById("loading").style.display = "none";
          document.getElementById("content").style.display = "grid";
        }

        showError(message) {
          document.getElementById("loading").style.display = "none";
          const errorDiv = document.getElementById("error");
          errorDiv.innerHTML = `<div class="error">${message}</div>`;
          errorDiv.style.display = "block";
        }
      }

      // Démarrage automatique
      new StyleguideGenerator();
    </script>
  </body>
</html>
